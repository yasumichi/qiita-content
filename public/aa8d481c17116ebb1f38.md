---
title: GitBucket Markdown Enhanced Plugin に Kroki サポートを追加しました
tags:
  - Scala
  - GitBucket
private: false
updated_at: '2026-01-18T16:29:28+09:00'
id: aa8d481c17116ebb1f38
organization_url_name: null
slide: false
ignorePublish: false
---
## 概要

[GitBucket](https://gitbucket.github.io/)用のプラグイン [GitBucket Markdown Enhanced Plugin](https://github.com/yasumichi/gitbucket-markdown-enhanced)を開発しています。

GitBucket Markdown Enhanced Plugin は、GitBucket 標準のマークダウンレンダリングエンジンを置き換えるプラグインです。

目標は、[Visual Studio Code](https://code.visualstudio.com/) の [Markdown Preview Enhanced](https://shd101wyy.github.io/markdown-preview-enhanced/#/) 向けの markdown ファイルを軽易に Web で共有できる環境です。

[GitBucket Markdown Enhanced Plugin 0.10.0](https://github.com/yasumichi/gitbucket-markdown-enhanced/releases/tag/v0.10.0) にて、[Kroki!](https://kroki.io/) を活用した図形描画をサポートしましたので紹介します。

なお、[インターネットに接続できない環境ではセルフホストの-kroki-を使用するように設定できます](#インターネットに接続できない環境ではセルフホストの-kroki-を使用するように設定できます)。

## 前回の記事

https://qiita.com/yasumichi/items/75bbec3f02e9e4b24bef

## マークダウンの記述例と変換結果のサンプル

[Visual Studio Code](https://code.visualstudio.com/) の [Markdown Preview Enhanced](https://shd101wyy.github.io/markdown-preview-enhanced/#/) の[例](https://shd101wyy.github.io/markdown-preview-enhanced/#/diagrams?id=kroki) を拝借します。(2番目の例は、そのままではエラーになったので余計な `;` を削除しています。)

<pre>
```blockdiag {kroki=true}
blockdiag {
  Kroki -> generates -> "Block diagrams";
  Kroki -> is -> "very easy!";

  Kroki [color = "greenyellow"];
  "Block diagrams" [color = "pink"];
  "very easy!" [color = "orange"];
}
```
</pre>

上記のように書くと次の画像に変換されます。

![](https://github.com/yasumichi/gitbucket-markdown-enhanced/raw/main/images/kroki-blockdiag.png)

<pre>
```javascript {kroki="wavedrom"}
{
  signal: [
    { name: "clk", wave: "p.....|..." },
    {
      name: "Data",
      wave: "x.345x|=.x",
      data: ["head", "body", "tail", "data"],
    },
    { name: "Request", wave: "0.1..0|1.0" },
    {},
    { name: "Acknowledge", wave: "1.....|01." },
  ]
}
```
</pre>

上記のように書くと次の画像に変換されます。

![](https://github.com/yasumichi/gitbucket-markdown-enhanced/raw/main/images/kroki-wavedrom.png)

ただし、[WaveDrom](https://github.com/wavedrom/wavedrom) であれば、ローカルでも生成できるので以下のように書いていただいた方が、余計な通信を発生させずに済みます。

<pre>
```wavedrom
{
  signal: [
    { name: "clk", wave: "p.....|..." },
    {
      name: "Data",
      wave: "x.345x|=.x",
      data: ["head", "body", "tail", "data"],
    },
    { name: "Request", wave: "0.1..0|1.0" },
    {},
    { name: "Acknowledge", wave: "1.....|01." },
  ]
}
```
</pre>

## インターネットに接続できない環境ではセルフホストの Kroki を使用するように設定できます

管理者権限が必要ですが、以下の手順で[セルフホストの Kroki](https://docs.kroki.io/kroki/setup/install/) を使用するように設定できます。

- 右上のユーザーアイコンをクリックし、`System administration` を選択
- 左側のサイドバーにある `Markdown Enhanced` をクリック

![](https://github.com/yasumichi/gitbucket-markdown-enhanced/raw/main/images/system-settings.png)

- 上記の画面にある `Kroki url` を変更

[Run multiple Kroki containers together](https://docs.kroki.io/kroki/setup/use-docker-or-podman/#_run_multiple_kroki_containers_together) の例にある `docker-compose.yml` を作成し、以下のコマンドで起動した場合は、　http://localhost:8000 を設定します。

```
$ docker compose up -d
```

- `Apply Changes` をクリック

`Settings Saved` と表示されれば、設定変更完了です。

## プレゼンテーション機能でも使用できます

[GitBucket Markdown Enhanced Plugin 0.9.0](https://github.com/yasumichi/gitbucket-markdown-enhanced/releases/tag/v0.9.0) では、限定的なダイアグラム記法しか使えませんでしたが、現在は、GitBucket Markdown Enhanced Plugin で使用できるダイアグラム記法は、すべて利用可能です。

<pre>
## kroki=true

```blockdiag {kroki=true}
blockdiag {
  Kroki -> generates -> "Block diagrams";
  Kroki -> is -> "very easy!";

  Kroki [color = "greenyellow"];
  "Block diagrams" [color = "pink"];
  "very easy!" [color = "orange"];
}
```

---
</pre>

上記のようにスライドが定義されていた場合、以下のように表示されます。

![](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/36738/1137fe7f-cba1-45b7-97fc-c0226fa4d5f4.png)

なお、[reveal.js](https://revealjs.com/) には、[PDF Export](https://revealjs.com/pdf-export/) が用意されており、手動で URL の末尾に `?print-pdf` というクエリストリングをつけると PDF レイアウトモードになります。ブラウザの印刷機能で PDF に変換することが可能です。

:::note warning
現状、上下中央揃えがなされないので調査中です。
:::

## ソースの変更点

### 設定の保存と読み込みを行うサービスの追加

[src/main/scala/io/github/yasumichi/gme/service/PluginSettingsService.scala](https://github.com/yasumichi/gitbucket-markdown-enhanced/blob/f6e65c09415254a40d34869584df3f6437b69a90/src/main/scala/io/github/yasumichi/gme/service/PluginSettingsService.scala) を新規に追加しました。

### 設定変更画面用の Twirl テンプレートを追加

[src/main/twirl/gme/settings.scala.html](https://github.com/yasumichi/gitbucket-markdown-enhanced/blob/f6e65c09415254a40d34869584df3f6437b69a90/src/main/twirl/gme/settings.scala.html) を新規に追加しました。

### 設定変更画面を司るコントローラーの追加

[src/main/scala/io/github/yasumichi/gme/controller/PluginSettingsController.scala](https://github.com/yasumichi/gitbucket-markdown-enhanced/blob/f6e65c09415254a40d34869584df3f6437b69a90/src/main/scala/io/github/yasumichi/gme/controller/PluginSettingsController.scala#L1) を新規に追加しました。

前項で作成した PluginSettingsService を継承しています。

### 作成したコントローラーのプラグインへの登録

[src/main/scala/Plugin.scala](https://github.com/yasumichi/gitbucket-markdown-enhanced/blob/f6e65c09415254a40d34869584df3f6437b69a90/src/main/scala/Plugin.scala#L139) を修正し、作成したコントローラーを追加しました。

```scala:src/main/scala/Plugin.scala
  override val controllers: Seq[(String, ControllerBase)] = Seq(
    "/*" -> new PresentationController(),
    "/admin" -> new PluginSettingsController()  // ←　今回追加した項目
  )
```

### 設定画面へのリンクを登録

前項で修正した src/main/scala/Plugin.scala に以下の行を追加しました。

```scala:src/main/scala/Plugin.scala
  override val systemSettingMenus: Seq[Context => Option[Link]] = Seq((ctx: Context) => Some(Link("Markdown-Enhanced", "Markdown Enhanced", "admin/markdown-enhanced")))
```

### リポジトリビューアー用に Kroki の画像を生成する処理を追加

[src/main/scala/io/github/yasumichi/gme/MarkdownEnhancedNodeRenderer.scala](https://github.com/yasumichi/gitbucket-markdown-enhanced/blob/f6e65c09415254a40d34869584df3f6437b69a90/src/main/scala/io/github/yasumichi/gme/MarkdownEnhancedNodeRenderer.scala#L111) の `renderFencedCodeBlock` で Kroki 用のコードブロックか判定する処理を追加しました。

```scala:src/main/scala/io/github/yasumichi/gme/MarkdownEnhancedNodeRenderer.scala
    val krokitrue = """.*\{.*kroki\s*=\s*true.*\}""".r
    val krokidia = """\{.*kroki\s*=\s*"(.*)".*\}""".r
    if (krokitrue.matches(info)) {
      return renderKroki(html, node, language.toString(), "svg")
    }
    krokidia.findFirstMatchIn(info) match {
      case Some(value) => return renderKroki(html, node, value.group(1), "svg")
      case None => None
    }
```

また、実際に SVG へ変換を行う `renderKroki` メソッドを追加しています。

```scala:src/main/scala/io/github/yasumichi/gme/MarkdownEnhancedNodeRenderer.scala
  private def renderKroki(html: HtmlWriter, node: FencedCodeBlock,  diagram_type: String, output_format: String): Unit = {
    implicit val formats = org.json4s.DefaultFormats
    var diagram_source: String = ""
    var seqs = node.getContentLines().toArray()
    for (i <- 0 to seqs.length - 1) diagram_source = diagram_source + seqs(i).toString()

    logger.debug(krokiUrl)

    try {
      val httpclient: CloseableHttpClient= HttpClients.createDefault();
      val httpPost = new HttpPost(krokiUrl)
      httpPost.addHeader("Content-Type", "application/json")
      val json = org.json4s.jackson.Serialization.write(KrokiParams(diagram_source, diagram_type, output_format))

      logger.debug(json)

      httpPost.setEntity(EntityBuilder.create().setContentType(ContentType.APPLICATION_JSON).setText(json).build())
      val res = httpclient.execute(httpPost)

      html.tag("div") 
      html.append(EntityUtils.toString(res.getEntity(), "UTF-8"))
      html.tag("/div")
    } catch {
      case e: Exception => {
        html.tag("div") 
        html.append(e.getMessage())
        html.tag("/div")
      }
    }
  }
```

[CORS](https://developer.mozilla.org/ja/docs/Web/HTTP/Guides/CORS) の沼にハマらないよう、サーバー側で Kroki と通信しています。

ブロッキングが発生するため、あまり、同じファイルに多くの Kroki コードを書くことは、推奨できません…。

### プレゼンテーション用に Kroki の画像を生成するハンドラーを追加

[src/main/scala/io/github/yasumichi/gme/controller/PresentationController.scala](https://github.com/yasumichi/gitbucket-markdown-enhanced/blob/f6e65c09415254a40d34869584df3f6437b69a90/src/main/scala/io/github/yasumichi/gme/controller/PresentationController.scala#L59) に以下のハンドラーを追加しました。

```scala:src/main/scala/io/github/yasumichi/gme/controller/PresentationController.scala
  ajaxPost("/:owner/:repository/kroki")(referrersOnly { repository =>
    implicit val formats = org.json4s.DefaultFormats
    val krokiUrl: String = loadSettings().krokiUrl
    val diagram_source: String = params("diagram_source")
    val diagram_type: String = params("diagram_type")
    val output_format: String = params("output_format")

    logger.debug(diagram_source)
    logger.debug(diagram_type)
    logger.debug(output_format)
    logger.debug(krokiUrl)

    try {
      val httpclient: CloseableHttpClient= HttpClients.createDefault();
      val httpPost = new HttpPost(krokiUrl)
      httpPost.addHeader("Content-Type", "application/json")
      val json = org.json4s.jackson.Serialization.write(PluginSettingsService.KrokiParams(diagram_source, diagram_type, output_format))

      logger.debug(json)

      httpPost.setEntity(EntityBuilder.create().setContentType(ContentType.APPLICATION_JSON).setText(json).build())
      val res = httpclient.execute(httpPost)

      EntityUtils.toString(res.getEntity(), "UTF-8")
    } catch {
      case e: Exception => e.getMessage()
    }
  })
```

### reveal.js を制御する JavaScript で Kroki 用のコードブロックを準備する処理を追加

[src/main/resources/gme/assets/presentation.js](https://github.com/yasumichi/gitbucket-markdown-enhanced/blob/f6e65c09415254a40d34869584df3f6437b69a90/src/main/resources/gme/assets/presentation.js#L11) でコードブロックを処理する `renderer.code` 関数に以下の処理を追加しました。

記法が特殊なため、他の記法より先に処理するようにしています。

```js:src/main/resources/gme/assets/presentation.js
        // check kroki
        var krokiPatterns = [/(.*)\s*\{.*kroki\s*=\s*true.*\}/, /.*\{.*kroki\s*=\s*"(.*)".*\}/];
        var isKroki = false;

        krokiPatterns.forEach((pattern) =>{
            var match = pattern.exec(language);
            if (match) {
                krokiNumber++;
                isKroki = true;
                html = `<div id="kroki-${krokiNumber}"></div>
                    <script type="kroki" class="kroki" data-type="${match[1].trim()}" data-target="#kroki-${krokiNumber}">
                    ${code}
                    </script>
                `;
            }
        })
```

### 準備したコードブロックに SVG を埋め込むための処理を追加

前項で修正した src/main/resources/gme/assets/presentation.js に SVG を埋め込むための `processKroki` 関数を追加しました。

```js:src/main/resources/gme/assets/presentation.js
    const processKroki = () => {
        return new Promise((resolve, reject) =>{
            let krokiList = document.querySelectorAll('.kroki');
            krokiList.forEach((node, index) => {
                let krokiId = node.getAttribute('data-target');
                let target = document.querySelector(krokiId);
                const params = new URLSearchParams();
                params.append("diagram_source", node.textContent);
                params.append("diagram_type", node.getAttribute('data-type'));
                params.append("output_format", "svg")
                const options = {
                    method: 'POST',
                    body: params
                };
                fetch(krokiUrl, options)
                    .then(res => {
                        if (res.ok) {
                            return res.text();
                        }
                    })
                    .then(data => {
                        target.innerHTML = data;
                        Reveal.layout();
                    });
            });
            resolve();
        });
    };
```

プレゼンテーション機能においても直接の Kroki との通信は避けています。

なお、前回の記事から、PlantUML の処理も追加していますが、類似の処理を行っています。

## おつかれさまでした

長い記事を最後まで読んでいただき、ありがとうございました。
